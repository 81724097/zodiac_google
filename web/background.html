<!doctype html>
<html>

<head>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.min.css">
    <link href="https://fonts.googleapis.com/css?family=Nunito" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <script src="jquery-3.2.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"></script>
    <script src="opencv.js" type="text/javascript"></script>
</head>

<body>
    <div id="banner-gradient" class="section no-pad-bot">
        <nav role="navigation" class="bg-none">
            <div class="nav-wrapper container"><a id="logo-container" href="#" class="brand-logo white-text">Shadowplay experiment</a>
            </div>
        </nav>
    </div>
    <div class="row">
        <div id="display_container" class="col s6 m4">
        </div>
        <div id="sample_container" class="col s6 m4">
        </div>
    </div>
    <footer class="page-footer light-red gram-footer">
        <div class="footer-copyright">
            <div class="container"><a href="http://bit.studio" class="white-text text-lighten-3"></a></div>
        </div>
    </footer>
    <!-- this page is generateded by Gramateria -->
    <script>
    function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    let zodiac = true;

    let height = 0;
    let width = 0;
    const FPS = 30;

    let canvasFrame = null;
    let context = null;
    let src = null;
    let background = null;
    let dst = null;
    let ones = null;
    let zeros = null;
    let disp = null;
    let disp_warpped = null;
    let M_raw_to_capture_to_disp = null;
    let M_raw_to_capture = cv.matFromArray(2, 3, cv.CV_64FC1, [1, 0, 0, 0, 1, 0]);
    let capture_res = null;
    let raw_to_capture_to_disp_ratio = null;

    let capture_x = 0;
    let capture_y = 0;
    let capture_res_percent = 0.5;
    let capture_alpha = 0.05;

    let raw_offset_x = 0;
    let raw_offset_y = 0;
    let raw_to_disp_ratio = null;
    let M_raw_to_disp = null;
    let disp_width = parseInt($(window).width() / 3 - 30);
    let disp_height = disp_width;
    let disp_offset_x = 0;
    let disp_offset_y = 0;

    let mode = 0;
    let mode_steps = 0
    let background_update_alpha = 0.05

    let video = null;
    let package = null;


    // tracking
    let tx = -1;
    let ty = -1;
    let ta = 0.1;
    let epsilon = 100;
    let countdown = 2000;
    let stamp = new Date().getTime();
    let allow_capture = true;

    function in_criterior(x, y) {
        return (x - tx) * (x - tx) + (y - ty) * (y - ty) < epsilon;
    }

    $(document).ready(function() {
        navigator.mediaDevices.getUserMedia({ video: { width: { min: 640 }, height: { min: 480 } }, audio: false })
            .then(function(stream) {
                init_webcam(640, 480, stream);
                setTimeout(processVideo, 0);
            })
            .catch(function(err) {
                console.log("An error occurred! " + err);
            });
    });


    function init_webcam(w, h, stream) {
        width = w;
        height = h;

        videoElement = $('<video id="videoInput" width="' + width + '" height="' + height + '"></video>');
        $('body').append(videoElement);
        // videoElement.hide();

        canvasElement = $('<canvas id="canvasFrame" width="' + width + '" height="' + height + '"></canvas>');
        $('body').append(canvasElement);
        canvasElement.hide();
        canvasFrame = document.getElementById("canvasFrame"); // canvasFrame is the id of <canvas>
        context = canvasFrame.getContext("2d");

        canvasElement = $('<canvas id="canvasOutput" width="' + disp_width + '" height="' + disp_height + '"></canvas>');
        $('#display_container').append(canvasElement);
        rawFrame = document.getElementById("canvasOutput");
        rawContext = rawFrame.getContext("2d");

        capture_res = Math.min(width, height)*capture_res_percent;
        dataElement = $('<canvas id="dataFrame" width="' + capture_res + '" height="' + capture_res + '"></canvas>');
        $('body').append(dataElement);
        dataElement.hide();

        capture_x = width/2;
        capture_y = height/2;
        M_raw_to_capture = cv.matFromArray(2, 3, cv.CV_64FC1, [1.0, 0, -(capture_x - capture_res*0.5), 0, 1.0, -(capture_y - capture_res*0.5)]);

        previewElement = $('<canvas id="previewFrame" width="' + disp_width + '" height="' + disp_height + '"></canvas>');
        $('#sample_container').prepend(previewElement);
        previewFrame = document.getElementById("previewFrame");
        previewContext = previewFrame.getContext("2d");
        
        raw_to_disp_ratio = disp_width * 1.0 / Math.min(width, height);
        raw_offset_x = (width - Math.min(width, height)) / 2;
        raw_offset_y = (height - Math.min(width, height)) / 2;
        M_raw_to_disp = cv.matFromArray(2, 3, cv.CV_64FC1, [raw_to_disp_ratio, 0, -raw_offset_x*raw_to_disp_ratio, 0, raw_to_disp_ratio, -raw_offset_y*raw_to_disp_ratio]);

        raw_to_capture_to_disp_ratio = disp_width * 1.0 / capture_res;

        M_raw_to_capture_to_disp = 
            cv.matFromArray(2, 3, cv.CV_64FC1, 
                [raw_to_capture_to_disp_ratio, 0, -(capture_x - capture_res*0.5)*raw_to_capture_to_disp_ratio, 0, raw_to_capture_to_disp_ratio, -(capture_y - capture_res*0.5)*raw_to_capture_to_disp_ratio]);

        src = new cv.Mat(height, width, cv.CV_8UC4);
        src_float = new cv.Mat(height, width, cv.CV_32FC4);
        background = new cv.Mat(height, width, cv.CV_8UC4, new cv.Scalar(0, 0, 0, 255));
        diff = new cv.Mat(height, width, cv.CV_8UC4);
        dst = new cv.Mat(height, width, cv.CV_8UC1);
        floatmap1 = new cv.Mat(height, width, cv.CV_32FC1);
        ones = new cv.Mat(height, width, cv.CV_8UC1, new cv.Scalar(255, 255, 255, 255));
        zeros = new cv.Mat(height, width, cv.CV_8UC1, new cv.Scalar(0, 0, 0, 255));
        disp = new cv.Mat(height, width, cv.CV_8UC4, new cv.Scalar(255, 255, 255, 255));
        disp_warpped = new cv.Mat(disp_height, disp_width, cv.CV_8UC4, new cv.Scalar(255, 255, 255, 255));
        preview_image = new cv.Mat(disp_height, disp_height, cv.CV_8UC4);
        data_image = new cv.Mat(capture_res, capture_res, cv.CV_8UC4);

        video = document.getElementById("videoInput"); // video is the id of video tag
        video.srcObject = stream;
        video.play();
    }

    function collectBackground() {
        cv.addWeighted(background, 1.0 - background_update_alpha, src, background_update_alpha, 0, background);
    }


    function processVideo() {
        let begin = Date.now();
        context.drawImage(video, 0, 0, width, height);
        src.data.set(context.getImageData(0, 0, width, height).data);
        cv.flip(src, src, 1);

        if (mode == 0) {

            collectBackground();

            cv.absdiff(src, background, diff);
            cv.cvtColor(diff, dst, cv.COLOR_RGBA2GRAY);

            kernel = new cv.Size(21, 21);
            cv.blur(dst, dst, kernel);
            maxTuple = cv.minMaxLoc(dst); 
            xy = maxTuple.maxLoc;
            max_value = maxTuple.maxVal;

            if(max_value < 30 && mode_steps > 20) {
                mode = 1;
                mode_steps = 0;
            }

            cv.warpAffine(src, disp_warpped, M_raw_to_disp, new cv.Size(disp_width, disp_height));
            cv.imshow("canvasOutput", disp_warpped);

            var dwcr = disp_width / (width - raw_offset_x*2);
            var dhcr = disp_height / (height - raw_offset_y*2);
            rawContext.strokeStyle = "blue";
            rawContext.rect((capture_x - capture_res*0.5 - raw_offset_x) * dwcr,
                (capture_y - capture_res*0.5 - raw_offset_y) * dhcr, capture_res * dwcr, capture_res * dhcr);
            rawContext.stroke();

            mode_steps = mode_steps + 1;

        }else if(mode == 1) {

            cv.absdiff(src, background, diff);
            cv.cvtColor(diff, dst, cv.COLOR_RGBA2GRAY);

            kernel = new cv.Size(5, 5)
            cv.blur(dst, dst, kernel)
            cv.threshold(dst, dst, 100, 255, cv.THRESH_TRIANGLE);
            cv.subtract(ones, dst, dst);

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(dst, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

            var max_i = 0;
            var max_size = 0;
            for (let i = 0; i < contours.size(); ++i) {
                var temp = contours.get(i)
                if (temp.rows > max_size) {
                    max_size = temp.rows;
                    max_i = i;
                }
                temp.delete();
            }

            disp.setTo(new cv.Scalar(0, 0, 0, 255));
            let color = new cv.Scalar(255, 255, 255, 255);
            cv.drawContours(disp, contours, max_i, color, cv.FILLED, cv.LINE_8, hierarchy, 1);

            let cnt = contours.get(max_i);
            let Moments = cv.moments(cnt, false);
            let cx = Moments.m10 / Moments.m00;
            let cy = Moments.m01 / Moments.m00;

            // console.log(cx, tx, cy, ty);
            if (in_criterior(cx, cy)) {
                if (new Date().getTime() - stamp > countdown) {
                    capture();
                }
            } else {
                stamp = new Date().getTime();
                allow_capture = true;
            }

            tx = tx * (1.0 - ta) + cx * ta;
            ty = ty * (1.0 - ta) + cy * ta;

            contours.delete();
            hierarchy.delete();

            cv.warpAffine(disp, disp_warpped, M_raw_to_capture_to_disp, new cv.Size(disp_width, disp_height));
            cv.imshow("canvasOutput", disp_warpped); // canvasOutput is the id of another <canvas>;
            // cv.imshow("canvasOutput", dst); // canvasOutput is the id of another <canvas>;

        }


        // schedule next one.
        let delay = 1000 / FPS - (Date.now() - begin);
        setTimeout(processVideo, delay);
    }
    // schedule first one.

    function capture() {
        if (!allow_capture) return;
        allow_capture = false;
        cv.warpAffine(disp, data_image, M_raw_to_capture, new cv.Size(capture_res, capture_res));
        
        cv.imshow("dataFrame", data_image);
        package = {
            reference: new Date().getTime(),
            setname: (getParameterByName("setname") || "test") + (zodiac? "_zodiac": "_puppet"),
            image: dataFrame.toDataURL()
        };

        classify();
    }

    function classify() {

        cv.resize(data_image, preview_image, new cv.Size(disp_width, disp_height));
        cv.imshow("previewFrame", preview_image);

        $.post("/classify", package, function(data, status, xhr) {
            console.log(data);
            
            var json = JSON.parse(data);
            for (var j = 0; j < json["classes"].length; ++j) {
                previewContext.fillStyle="#FFFFFF";
                previewContext.fillRect(40,35 + 20*j,40,20);
                previewContext.fillStyle="#000000";
                previewContext.font="18px Arial";
                previewContext.fillText(json["classes"][j].toString(), 50, 50 + 20*j);
            }

        });
    }
    </script>
</body>

</html>
